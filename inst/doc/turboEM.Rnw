%\VignetteIndexEntry{turboEM Tutorial}
%\VignetteDepends{setRNG}
%\VignetteKeywords{optimization, EM algorithm, MM algorithm, fixed-point iteration}
%\VignettePackage{turboEM}

\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsfonts}
%\usepackage{natbib}
\usepackage{graphicx}
\usepackage{color} %% red, green, and blue (for screen display) and cyan, magenta, and yellow
\usepackage{hyperref}

\newcommand{\compresslist}{%
%\setlength{\itemsep}{1pt}%
\setlength{\itemsep}{0pt}%
\setlength{\parskip}{0pt}%
\setlength{\parsep}{0pt}%
}

\newcommand{\pb}{\mathbb{P}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\bea}{\begin{align*}}
\newcommand{\eea}{\end{align*}}
\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\renewcommand{\baselinestretch}{1}

\title{turboEM: An R package to accelerate the EM algorithm}
% \author{Jennifer F. Bobb}
\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
In the R package ``turboEM'' four schemes to accelerate the EM algorithm have been implemented.
The four accelerators are SQUAREM~\cite{VaradhanRoland2008}, Parabolic EM~\cite{BerlinetRoland2009}, a quasi-Newton algorithm~\cite{Zhou2011}, and Dynamic ECME~\cite{HeLiu2010}. The main function \texttt{turboem()} allows the user to fit one or more of the acceleration schemes for a given starting value and fixed point mapping function. The \texttt{turboem()} function outputs an object of class \texttt{turbo}. Methods implemented for the \texttt{turbo} class are \texttt{print}, \texttt{pars}, \texttt{error}, \texttt{plot}, \texttt{grad}, \texttt{hessian}, and \texttt{stderror}.

We have also developed methods to summarize and display results from a simulation study comparing accelerators. For an object resulting from a simulation study of class \texttt{turbosim}, the methods \texttt{summary}, \texttt{boxplot}, \texttt{dataprof}, and \texttt{pairs} have been implemented.

In this document we first provide an overview of the \texttt{turbem} function. We then demonstrate its use through an example. Last, we demonstrate how a simulation study to compare acceleration schemes may be conducted and results visualized using the class \texttt{turbosim} and its corresponding methods.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
First load the \texttt{turboEM} R package, which includes the \texttt{turboem} function and its associated methods.
<<load>>=
##source("~/Dropbox/GSoC_EMacceleration/Overall Function/overallFunction.R")
##source("~/Dropbox/GSoC_EMacceleration/Overall Function/turboClassMethods.R")
library(turboEM)
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Usage}
<<showcode, eval=FALSE>>=
turboem(par, fixptfn, objfn, method = c("em", "squarem", "pem", "decme", "qn"), boundary, pconstr = NULL, project = NULL, ...,
  control.method = replicate(length(method),list()), control.run = list())
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Arguments}
\bi\compresslist
\item \texttt{par}: A vector of parameters denoting the initial guess for the fixed point
  \item \texttt{fixptfn}: A vector function $F$ that denotes the fixed-point mapping. This function should accept a parameter vector as input and should return a parameter vector of the same length. This function defines the fixed-point iteration $x_{k+1} = F(x_k)$. In the case of EM algorithm, $F$ defines a single E- and M-step.
    \item \texttt{objfn}: This is a scalar function, $L$, that denotes a ``merit'' function which attains its local minimum at the fixed-point of $F$.  This function should accept a parameter vector as input and should return a scalar value.  In the EM algorithm, the merit function $L$ is the negative log-likelihood. In some problems, a natural merit function may not exist. However, this argument is required for all of the algorithms *except* SQUAREM (which defaults to SQUAREM-2 if \texttt{objfn} not provided) and EM.
      \item \texttt{method}: Specifies which algorithm(s) will be applied. Must be a vector containing one or more of \texttt{c("em", "squarem", "pem", "decme", "qn")}.
        \item \texttt{boundary}: Argument required for Dynamic ECME (\texttt{"decme"}) only. Function to define the subspaces over which the line search is conducted.
          \item \texttt{pconstr}: Optional function for defining boundary constraints on parameter values. Function maps a vector of parameter values to TRUE if constraints are satisfied. Note that this argument is only used for SQUAREM (\texttt{squarem}), Parabolic EM (\texttt{pem}), and quasi-Newton (\texttt{qn}) algorithms, and it has no effect on the other algorithms.
          \item \texttt{project}: Optional function for defining a projection that maps an out-of-bound parameter value into the constrained parameter space. Requires the \texttt{pconstr} argument to be specified in order for the \texttt{project} to be applied.
          \item \texttt{control.method}: if \texttt{method = c(method1, method2, ...)}, then \texttt{conrol.method = list(list1, list2, ...)} where \texttt{list1} is the list of control parameters for \texttt{method1}, \texttt{list2} is the list of control parameters for \texttt{method2}, and so on. If \texttt{length(method) == 1}, then \texttt{control.method} is the list of control parameters for the acceleration scheme.
            \item \texttt{control.run}: A list of control parameters for convergence and stopping the algorithms. See *Details* under \texttt{help("turboem")} and Section~\ref{sec:stopcrit} below.
          \item \ldots: Arguments passed to \texttt{fixptfn} and \texttt{objfn}

\ei
\subsection*{Value}
The function \texttt{turboem} returns an object of class \texttt{turbo}. An object of class \texttt{turbo} is a list containing at least the following components:
\bi\compresslist
 \item \texttt{fail}: A vector of logical values whose $j$th element indicates whether algorithm $j$ failed (produced an error)
   \item \texttt{value.objfn}: A vector of the value of the objective function at termination for each algorithm
    \item \texttt{itr}: A vector of the number of iterations completed for each algorithm
      \item \texttt{fpeval}: A vector of the number of fixed-point evaluations completed for each algorithm
        \item \texttt{objfeval}: A vector of the number of objective function evaluations completed for each algorithm
     \item \texttt{convergence}: A vector of logical values whose $j$th element indicates whether algorithm $j$ satisfied the convergence criterion before termination
    \item \texttt{runtime}: A matrix whose $j$th row contains the ``user'', ``system'', and ``elapsed'' time for running the $j$th algorithm
     \item \texttt{errors}: A vector whose $j$th element is either NA or contains the error message from running the $j$th algorithm
      \item \texttt{pars}: A matrix whose $j$th row contains the fixed-point parameter values at termination for the $j$th algorithm
       \item \texttt{trace.objfval}: if \texttt{control.run[["keep.objfval"]]=TRUE}, contains a list whose $j$th component is a vector of objective function values across iterations for the $j$th algorithm
\ei
The list will also contain the components \texttt{method}, \texttt{control.method}, \texttt{control.run}, \texttt{fixptfn}, \texttt{objfn}, \texttt{pconstr}, and \texttt{project}, which were provided as arguments for \texttt{turboem}.
% \subsection*{Defaults}
% \color{magenta}
% I will add this subsection later. Here we can describe the default implementations for each of the EM accelerators.
% \color{black}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example}
The example we consider is a mixture of two Poisson distributions. Data are from Hasselblad (JASA 1969).
<<data>>=
poissmix.dat <- data.frame(death=0:9, freq=c(162,267,271,185,111,61,27,8,3,1))
y <- poissmix.dat$freq
## number of parameters
npar <- 3
@
The fixed point mapping of the EM algorithm may be coded as
<<fixptfn>>=
fixptfn <- function(p, y) {
	pnew <- rep(NA,3)
	i <- 0:(length(y)-1)
	zi <- p[1]*exp(-p[2])*p[2]^i / (p[1]*exp(-p[2])*p[2]^i + (1 - p[1])*exp(-p[3])*p[3]^i)
	pnew[1] <- sum(y*zi)/sum(y)
	pnew[2] <- sum(y*i*zi)/sum(y*zi)
	pnew[3] <- sum(y*i*(1-zi))/sum(y*(1-zi))
	p <- pnew
	return(pnew)
}
@
The objective function to be minimized (negative log-likelihood) is as follows.
<<objfn>>=
objfn <- function(p, y) {
	i <- 0:(length(y)-1)
	loglik <- y*log(p[1]*exp(-p[2])*p[2]^i/exp(lgamma(i+1)) + (1 - p[1])*exp(-p[3])*p[3]^i/exp(lgamma(i+1)))
	return ( -sum(loglik) )
}
@
\subsection{Illustration of basic features}
First, we demonstrate how to use \texttt{turboem} to fit the EM algorithm as well as the SQUAREM and Parabolic EM acceleration schemes, using the default settings for each algorithm.
<<fit1>>=
res <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn,
	       method=c("em", "squarem", "pem"), y=y)
options(digits=13)
res
@
We see that the EM algorithm did not achieve convergence at the default tolerance within the allotted 1500 iterations.

Using the \texttt{pars} method, we can look at the parameter values obtained across the three algorithms:
<<pars>>=
pars(res)
@
We can also compute the gradient, hessian, and standard error estimates for the parameter values.
<<showmethods>>=
options(digits=7)
grad(res)
hessian(res)
stderror(res)
@
We can also compare the objective function value over time across the different methods. To do this, we must specify that we would like \texttt{turboem} to store the computed value at each iteration.
\begin{center}
<<plot, fig=TRUE, width=5, height=4, echo=TRUE>>=
res1 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn, method=c("em", "squarem", "pem"), y=y,
		control.run=list(keep.objfval=TRUE))
res1
plot(res1, xlim=c(0.001, 0.02))
@
\end{center}
In order to apply the dynamic ECME acceleration scheme, one must specify the subspace over which line searches will be conducted. This is done through specification of the \texttt{boundary} function. Given the current parameter value \texttt{par} and the direction of the search \texttt{dr}, the function defining the subspace at each iteration for this example is given by
<<boundary>>=
boundary <- function(par, dr) {
	lower <- c(0, 0, 0)
	upper <- c(1, 10000, 10000)
	low1 <- max(pmin((lower-par)/dr, (upper-par)/dr))
	upp1 <- min(pmax((lower-par)/dr, (upper-par)/dr))
	return(c(low1, upp1))
}
@
We can now use \texttt{turboem} for the Dynamic ECME algorithm, as follows.
<<fit1>>=
res2 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn, boundary=boundary, method="decme", y=y)
options(digits=13)
res2
@
For some problems, an objective function may not be available. Only SQUAREM and EM do not require an objective function to be provided. The other algorithms, parabolic EM, quasi-Newton, and Dynamic ECME, will produce an error message if no objective function is provided.
<<noobjfn>>=
res3 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, boundary=boundary, y=y)
res3
error(res3)
@

In certain circumstances, quasi-Newton may produce invalid parameter values (e.g. values outside the parameter space). For example, if we use as a starting value a point near the boundary of the parameter space, quasi-Newton will produce an error:
<<noobjfn>>=
res4 <- turboem(par=c(0.9, 1, 3), fixptfn=fixptfn, objfn=objfn, boundary=boundary, y=y)
res4
@
Invalid parameter values at a particular iteration of quasi-Newton typically yields the following error message
<<err>>=
error(res4)
@
One way to rectify this problem is to include the \texttt{pconstr} argument, which defines the bounds of the parameter space
<<fit3>>=
pconstr <- function(par) {
	lower <- c(0, 0, 0)
	upper <- c(1, Inf, Inf)
	return(all(lower < par & par < upper))
}
res5 <- turboem(par=c(0.9, 1, 3), fixptfn=fixptfn, objfn=objfn, boundary=boundary, y=y, pconstr=pconstr)
res5
@

\subsection{Alternative stopping criteria}
\label{sec:stopcrit}
Stopping criteria for each algorithm may be specified through the \texttt{control.run} argument. Default values of \texttt{control.run} are:
\begin{verbatim}
   convtype="parameter",
   tol=1.0e-07,
   stoptype="maxiter",
   maxiter=1500,
   maxtime=60,
   convfn.user=NULL,
   stopfn.user=NULL,
   trace=FALSE,
   keep.objfval=FALSE.
\end{verbatim}

There are two ways the algorithm will terminate. Either the algorithm will terminate if convergence has been achieved, or the algorithm will terminate if convergence has not been achieved within a pre-specified maximum number of iterations or maximum running time (alternative stopping criterion).
At each iteration for each acceleration scheme, both the convergence criterion and the alternative stopping criterion will be checked.
The arguments \texttt{convtype}, \texttt{tol}, and \texttt{convfn.user} control the convergence criterion. The arguments \texttt{stoptype}, \texttt{maxiter}, \texttt{maxtime}, and \texttt{stopfn.user} control the alternative stopping criterion.

Two types of convergence criteria have been implemented, with an option for the user to define his/her own convergence criterion. If \texttt{convtype="parameter"} (the default setting), then the default convergence criterion is to terminate if
%\texttt{sqrt(crossprod(new-old)) < tol}, where \texttt{new} denotes the current value of the fixed point and \texttt{old} denotes the previous fixed-point value.
at the first iteration $n$ satisfying
$$
\left\{\sum_{k=1}^K(p_k^{(n)}-p_k^{(n-1)})^2\right\}^{1/2} < \mathtt{tol},
$$
where $p_k^{(n)}$ denotes the $k$th element of the fixed-point value $p$ at the $n$th iteration. For example, to set the convergence criterion to be $\left\{\sum_{k=1}^K(p_k^{(n)}-p_k^{(n-1)})^2\right\}^{1/2} < 10^{-10}$ we specify \texttt{control.run} as
<<changetol>>=
res6 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn,
		method=c("em", "pem", "squarem"), y=y,
		control.run=list(tol=1.0e-10))
res6
@
By specifying \texttt{convtype="objfn"}, the default convergence criterion is to terminate at the first iteration $n$ such that
%\texttt{abs(new-old) < tol}, where \texttt{new} denotes the current value of the objective function and \texttt{old} denotes the previous value of the objective function.
$$
\left|L(\mathtt{par}_n) - L(\mathtt{par}_{n-1})\right| < \mathtt{tol}.
$$
For example, to set the convergence criterion to be $|L(\mathtt{par}_n) - L(\mathtt{par}_{n-1})| < 10^{-10}$ we specify \texttt{control.run} as follows
<<objfnconv>>=
res7 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn, method=c("em", "pem", "squarem"), y=y, control.run=list(tol=1.0e-10, convtype="objfn"))
res7
@
If the user desires alternate convergence criteria, \texttt{convfn.user} may be specified as a function with inputs \texttt{new} and \texttt{old} that maps to a logical taking the value TRUE if convergence is achieved and the value FALSE if convergence is not achieved. For example, to set the convergence rule to be $\max\{\left|\mathtt{par}_n - \mathtt{par}_{n-1}\right|\} < 10^{-10}$, \texttt{control.run} may be specified as follows
<<userdefconv>>=
convfn.user <- function(old, new) {
	max(abs(new-old)) < tol
}
res8 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn,
		method=c("em", "pem", "squarem"), y=y,
		control.run=list(tol=1.0e-10, convfn.user = convfn.user))
res8
@
Similarly, to set the convergence rule to be
$$
\frac{|L(\mathtt{par}_n) - L(\mathtt{par}_{n-1})|}{|L(\mathtt{par}_{n-1})| + 1} < 10^{-8},
$$
\texttt{control.run} may be specified as follows
<<userdefconv2>>=
convfn.user <- function(old, new) {
	abs(new - old)/(abs(old) + 1) < tol
}
res9 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn, method=c("em", "pem", "squarem"), y=y, control.run=list(tol=1.0e-8, convtype="objfn", convfn.user = convfn.user))
res9
@

Two types of alternative stopping criteria have been implemented, with the option for the user to define his/her own stopping criterion. If \texttt{stoptype="maxiter"} (the default setting), then the algorithm will terminate if convergence has not been achieved within \texttt{maxiter} iterations of the acceleration scheme.
If \texttt{stoptype="maxtime"}, then the algorithm will terminate if convergence has not been achieved within \texttt{maxtime} seconds of running the acceleration scheme. Note that the running time of the acceleration scheme is calculated once every iteration. For example, the code
<<newstop>>=
res10 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn,
		method=c("em", "pem", "squarem"), y=y,
		control.run=list(tol=1.0e-15, stoptype="maxtime", maxtime=10))
res10
@
imposes a strict convergence criterion, but allows the algorithms up to 10 seconds to run.

If the user desires different alternate stopping criteria than those implemented, \texttt{stopfn.user} may be specified as a function with no inputs that maps to a logical taking the value TRUE which leads to the algorithm being terminated or the value FALSE which leads to the algorithm proceeding as usual. For example, if the user desires the function to stop if either the maximum number of iterations is above 2000 or the maximum running time is above 0.2 seconds, this may be achieved by
<<newstop2>>=
stopfn.user <- function() {
	iter >= maxiter | elapsed.time >= maxtime
}
res11 <- turboem(par=c(0.5, 1, 3), fixptfn=fixptfn, objfn=objfn,
		method=c("em", "pem", "squarem"), y=y,
		control.run=list(tol=1.0e-15, stopfn.user=stopfn.user, maxtime=0.2, maxiter=2000))
res11
@

\subsection{Changing default configurations of the acceleration algorithms}

Instead of using the default implementations of each acceleration scheme, we may use alternative specifications. For example, we might like to compare higher-order SQUAREM algorithms (e.g. $K=2$ or $K=3$), consider different values for the $qn$ parameter in the quasi-Newton class of schemes, or use a different version of the dynamic ECME scheme. In the next code chunk, we compare the EM algorithm to the following accelerators: SQUAREM with $K=2$ and $K=3$, Dynamic ECME versions 2 and 2s, quasi-Newton with $qn=1$ and $qn=2$, and Parabolic EM versions ``arithmetic'' as well as the default ``geometric''.
<<fit2>>=
res12 <- turboem(par = c(0.9, 1, 3), fixptfn=fixptfn, objfn=objfn, boundary=boundary, pconstr=pconstr, method=c("em", "squarem", "squarem", "decme", "decme", "qn", "qn", "pem", "pem"), control.method=list(list(), list(K=2), list(K=3), list(version=2), list(version="2s"), list(qn=1), list(qn=2),
		list(version="arithmetic"), list(version="geometric")), y=y)
res12
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Benchmark study illustration}
We conduct a small benchmark study to compare EM accelerators for this Poisson mixture example in order to illustrate the benchmark visualization tools implemented in the R package.

For each of $r=1,\ldots,\mathtt{NREP}$ repetitions, we randomly simulate a starting value $\mathtt{par}^{(r)}$. We then apply each of the EM accelerators, beginning at that starting value.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Control parameters}
Because each of the acceleration schemes has different versions and control parameters, we create a list containing the control parameters for each scheme we will consider
<<control>>=
method.names <- c("EM", "squaremK1", "squaremK2", "parabolicEM", "dynamicECME", "quasiNewton")
nmethods <- length(method.names)
method <- c("em", "squarem", "squarem", "pem", "decme", "qn")
control.method <- vector("list", nmethods)
names(control.method) <- method.names
control.method[["EM"]] <- list()
control.method[["squaremK1"]] <- list(K=1)
control.method[["squaremK2"]] <- list(K=2)
control.method[["parabolicEM"]] <- list(version="geometric")
control.method[["dynamicECME"]] <- list(version="v2")
control.method[["quasiNewton"]] <- list(qn=2)
@
We also set the control parameters for stopping the algorithm, including the convergence rule and an alternative stopping rule (setting the maximum runtime or maximum number of iterations).
<<runparams>>=
control.run <- list(tol=1e-7, stoptype="maxtime", maxtime=2, convtype="parameter")
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Starting values}
We generate the starting values $\mathtt{par}^{(r)}, r=1,\ldots,\mathtt{NREP}$. To ensure reproducibility, we set the seed.
<<seed>>=
NREP <- 100
library(setRNG)
test.rng <- list(kind = "Mersenne-Twister", normal.kind = "Inversion", seed = 1)
setRNG(test.rng)
starting.values <- cbind(runif(NREP),runif(NREP,0,4),runif(NREP,0,4))
head(starting.values, 3)
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Execute simulation}
Now we run the simulation. For each acceleration scheme, we will keep track of whether the algorithm produced an error, whether the algorithm converged, the total number of iterations until convergence, the execution time, and the final value of the negative log-likelihood function.
<<run, cache=TRUE>>=
runtime <- niter <- negloglik <- conv <- fail <- errors <- matrix(NA, NREP, nmethods)
options(digits=13)
tot.time1 <- Sys.time()
for(i in 1:NREP) {
	p.start <- starting.values[i,]

	res <- try(turboem(par=p.start, fixptfn=fixptfn, objfn=objfn, y=y, method=method, boundary=boundary, pconstr=pconstr, control.method=control.method, control.run=control.run))
	if(class(res)=="try-error") {
		fail[i,] <- TRUE
	} else {
		runtime[i,] <- res$runtime[,"elapsed"]
		negloglik[i,] <- res$value.objfn
		conv[i,] <- res$convergence
		niter[i,] <- res$itr
		fail[i,] <- res$fail
		errors[i,] <- res$errors
	}
}
tot.time2 <- Sys.time()
@
The total simulation running time for the $NREP=\Sexpr{NREP}$ iterations is
<<difftime>>=
difftime(tot.time2, tot.time1)
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Results}
We create an object of class \texttt{turbosim} so that we can summarize and visualize the results of our simulation.
<<object>>=
results <- list(method.names=method.names, fail=fail, conv=conv, value.objfn=negloglik, runtime=runtime, method=method, control.method=control.method, control.run=control.run)
class(results) <- "turbosim"
@
An object of class \texttt{turbosim} is a list containing at least the following components:
\bi\compresslist
\item \texttt{method.names}: A vector of unique identifiers for the algorithms being compared
  \item \texttt{fail}: A matrix whose $(i,j)-$element is a logical (TRUE/FALSE) for whether the $j$th algorithm at the $i$th simulation iteration failed (produced an error)
      \item \texttt{conv}: A matrix whose $(i,j)-$element is a logical (TRUE/FALSE) for whether the $j$th algorithm at the $i$th simulation iteration satisfied the convergence criterion before termination
          \item \texttt{value.objfn}: A matrix whose $(i,j)-$element is the value of the objective function of the $j$th algorithm at the $i$th simulation iteration
              \item \texttt{runtime}: A matrix whose $(i,j)-$element is the running time of the $j$th algorithm at the $i$th simulation iteration
\ei
This list will also contain the components \texttt{method}, \texttt{control.method}, and \texttt{control.run} which were provided as arguments for \texttt{turboem} in the main function call of the simulation.

There are four methods associated with the class \texttt{turbosim}, namely \texttt{summary}, \texttt{boxplot}, \texttt{dataprof}, and \texttt{pairs}. We next illustrate the use of each method for our simulation.

The method \texttt{summary} prints a table of the number of failures across acceleration schemes. We consider three types of failures. The first occurs when the algorithm produces an error message. The second is if the algorithm does not converge before the alternative stopping rule is satisfied (e.g. the maximum number of iterations or maximum prespecified runtime is achieved). The third type of failure occurs if the algorithm claims convergence but the value of the objective function is ``far'' from the best achievable value. To assess this third type of failure, we determine whether the objective function value acheived by the algorithm is close (within a pre-specified value, \texttt{eps}) to the smallest value achieved across all algorithms at that iteration. A summary of the failures across iterations by algorithm is given by the method \texttt{summary}.
<<table>>=
summary(results, eps=0.01)
@
Alternatively, say we knew somehow that the global minimum of the objective function for this problem were $\mathtt{sol} = 1989.945859883$. In this case the third type of failure would occur of the objective function value acheived by the algorithm is more than \texttt{eps} units greater than \texttt{sol}, and we could summarize the failures using
<<table2>>=
summary(results, eps=0.01, sol=1989.945859883)
@

The \texttt{boxplot} method shows boxplots of the running time across simulation iterations for each acceleration scheme. We can specify the argument \texttt{whichfail} which identifies which of the simulation iterations were failures. These iterations will be excluded in the boxplots. For example, if we wish to plot the iterations for which the algorithms did not produce an error, we would use the command
\begin{center}
<<boxplots, fig=TRUE, width=6, height=3, echo=TRUE, eval=TRUE>>=
boxplot(results, whichfail = results$fail)
@
\end{center}
The default setting for \texttt{whichfail} in \texttt{boxplot}, as in the other methods for the \texttt{turbosim} class, excludes those simulation iterations for which either the algorithm produced an error or convergence was not achieved.

The \texttt{dataprof} method shows the estimated distribution function of the time until convergence ($T$) for each acceleration scheme.
%In this example, none of the three types of failure were achieved by any of the algorithms. However, if some algorithms had yielded failures, we would set $T_{i,j}=\infty$ for those iterations $i$ where algorithm $j$ failed.
We set $T_{i,j}=\infty$ for those iterations $i$ where algorithm $j$ failed, where failures are specified using the \texttt{whichfail} argument of \texttt{dataprof()}.
\begin{center}
<<dataprofile, fig=TRUE, width=5.5, height=5.5, echo=TRUE>>=
dataprof(results, xlim=c(0, 0.005))
@
\end{center}

Finally, to visualize pairwise comparisons of the running time across algorithms at each iteration, we implement the \texttt{pairs} method which displays a scatterplot matrix of the run times. For this method, as with the other methods, we can specify which of the algorithms will be shown in the results by specifying \texttt{which.methods}.
\begin{center}
<<scatterplot, fig=TRUE, width=9, height=8, echo=TRUE>>=
pairs(results, which.methods=1:4, cex=0.8, whichfail=with(results, fail | !conv | value.objfn > apply(value.objfn, 1, min) + 0.01))
@
\end{center}
Rather than ignore points where one of the pair of algorithms failed, we plot those points along the far right or topmost part of the plot.
For example, for those iterations where \texttt{squaremK2} failed, we set the running time for those iterations to the maximum running time of \texttt{squaremK2} across iterations, and we color-coded the point as having a greater running time as compared to the algorithm that did not fail. The scatterplots also include the robust linear regression fit (using the L1 norm) constrained so that the intercept is 0.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{1}
%bibliographystyle{chicago}
\bibitem{VaradhanRoland2008} Varadhan and Roland (2008). Simple and Globally Convergent Methods for Accelerating the Convergence of Any EM Algorithm. Scand J Stat. 35 (2) 335-3531
\bibitem{BerlinetRoland2009} Berlinet and Roland (2009). Parabolic acceleration of the EM algorithm. Stat Comput. 19 (1) 35-47
\bibitem{Zhou2011} Zhou et al (2011). A quasi-Newton acceleration for high-dimensional optimization algorithms. Stat Comput. 21 (2) 261-273
\bibitem{HeLiu2010} He and Liu (2010) The Dynamic ECME Algorithm. Technical Report. arXiv:1004.0524v1
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
